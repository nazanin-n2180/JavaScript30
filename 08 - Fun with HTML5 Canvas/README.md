<div dir="rtl">

# تمرین ۸: بازی با Canvas در HTML5

عنصر `canvas` در وب، تقریبا مثل Microsoft Paint است که یک بلوک از پیکسل‌ها را برای نقاشی کشیدن در اختیار کاربر می‌گذارد. کاربر دقیقا روی عنصر `canvas` در HTML نقاشی نمی‌کند بلکه روی `context` این کار را انجام می‌دهد. ‍`context` میتواند 2D (چیزی که در این تمرین ساخته می‌شود) و 3D (برای بازی‌ها و 3D rendering) باشد.

## خلاصه

عنصر `<canvas>` در HTML5 یک فضای نقاشی در اختیار ما می‌گذارد که شبیه یک تخته‌سفید دیجیتال عمل می‌کند. کاربر مستقیماً روی خود عنصر چیزی ترسیم نمی‌کند، بلکه روی `context` آن کار می‌کند. این `context` می‌تواند دوبعدی یا سه‌بعدی باشد. در این تمرین با `context` دوبعدی کار می‌کنیم و خطوطی رسم می‌کنیم که به‌صورت پویا رنگ و ضخامتشان تغییر می‌کند.

فرایند کلی پیاده‌سازی به این صورت است که ابتدا عنصر `canvas` و `context` آن را مقداردهی می‌کنیم و سپس اندازه بوم را با اندازه پنجره مرورگر هماهنگ می‌سازیم. رویدادهای ماوس را مدیریت می‌کنیم تا بفهمیم چه زمانی رسم شروع یا متوقف شود. یک تابع `draw` داریم که مسیر خط را مشخص می‌کند و سپس آن را روی `canvas` می‌کشد. برای جذاب‌تر شدن خروجی، رنگ خطوط در یک چرخه HSL تغییر می‌کند و ضخامت آن‌ها نیز به شکل رفت و برگشتی کم و زیاد می‌شود. در نهایت، می‌توانیم با استفاده از Blend Modeها افکت‌های جالب‌تری برای خطوط ایجاد کنیم.

## مراحل پیاده‌سازی

۱. دو متغیر تعریف کنید. متغیر اول را به عنصر `canvas` در HTML ارجاع دهید. در متغیر دوم، با استفاده از <span dir="ltr">`.getContext('2d')`</span>، نوع `context` موردنظر را مشخص کرده و آن را در متغیر ذخیره کنید.

۲. اندازه پیش‌فرض `canvas` در HTML، ۸۰۰ در ۸۰۰ پیکسل تعریف شده است. در JavaScript، اندازه آن را طوری تعریف کنید که هم‌اندازه با فضای داخلی پنجره برنامه باشد.

۳. حالت اولیه `strokeStyle` (رنگ اولیه خطوطی که روی `canvas` کشیده می‌شود)، `lineCap` (حالت انتهای خطوط)، `lineJoin` (حالت محل وصل شدن خطوط به هم) و `lineWidth` (مقدار کلفت بودن خطوط) را به‌صورت زیر تعریف کنید.

```javascript
ctx.strokeStyle = '#BADA55';
ctx.lineCap = 'round';
ctx.lineJoin = 'round';
ctx.lineWidth = 100;
```

۴. سه متغیر تعریف کنید:
<ul>
   <li>متغیر <code>isDrawing</code> برای تعیین وضعیت کلیک ماوس و با مقدار اولیه <code>false</code>.</li>
   <li>متغیر <code>lastX</code> برای تعیین موقعیت اشاره‌گر ماوس روی محور افقی صفحه و با مقدار اولیه 0</li>
   <li>متغیر <code>lastY</code> برای تعیین موقعیت اشاره‌گر ماوس روی محور عمودی صفحه و با مقدار اولیه 0</li>
</ul>

۵. اولین `event listener` روی عنصر `canvas`، به رویداد `mousedown` گوش می‌کند. تابع event handler آن، یک آرگومان رویداد (یعنی e) را می‌گیرد، مقدار متغیر `isDrawing` برابر با `true` و مقدار متغیرهای `lastX` و `lastY` را، به ترتیب، برابر `e.offsetX` و `e.offsetY` قرار می‌دهد.

۶.  روی عنصر `canvas` دو `event listener` دیگر اضافه کنید که به رویدادهای `mouseup` و `mouseout` گوش کنند و مقدار متغیر `isDrawing` را به `false` تغییر دهند.

۷. آخرین `event listener` روی عنصر `canvas`، به رویداد `mousemove` گوش می‌کند و تابع مرحله بعد را به‌عنوان event handler اجرا می‌کند.

۸. تابع `draw` را به عنوان تابع event handler تعریف کنید:
> آرگومان رویداد یعنی e را فراموش نکنید.
<ul>
<li>تابع نباید وقتی کلیک ماوس اتفاق نیوفتاده اجرا شود. بنابراین وقتی متغیر <code>isDrawing</code> مقدار <code>false</code> دارد، اجرای تابع را متوقف کنید.</li>
<li>با استفاده از متغیری که <code>context</code> در آن ذخیره شده و <code><span dir="ltr">.beginPath</span></code>، یک <code>path</code> ایجاد کنید.</li>
<li>باید مختصات شروع و مختصات نقاطی که اشاره‌گر ماوس به آن‌ها می‌رود را برای رسم خطوط داشته باشیم:<br>
<code><span dir="ltr"><pre>ctx.moveTo(lastX, lastY);
ctx.lineTo(e.offsetX, e.offsetY);</pre></span></code></li>
<li>در آخر، <code><span dir="ltr">ctx.stroke()</span></code> را فراخوانی کنید تا خط مورد نظر کشیده شود.</li>
<li>مقدار متغیرهای <code>lastX</code> و <code>lastY</code> را،به ترتیب، برابر با <code>e.offsetX</code> و <code>e.offsetY</code> قرار می‌دهیم.</li>
</ul>

> تا اینجا، یک حالت خیلی ساده و پایه از نقاشی روی canvas رو داریم. از اینجا به بعد، برای فانه 😁

۹. در سیستم رنگ [HSL](https://mothereffinghsl.com/)، رنگ (hue) از 0 (قرمز) تا 360 (دوباره قرمز) تغییر می‌کند. بنابراین، می‌توانیم یک الگوی تکرار شونده از رنگ‌ها برای نقاط روی خطوط داشته باشیم که هر 360 بار تکرار می‌شوند. برای عوض شدن رنگ خطوط هنگام رسم آن‌ها:
<ul>
<li>بعد از متغیرهای مرحله ۴، یک متغیر <code>hue</code> با مقدار اولیه 0 تعریف کنید.</li>
<li>در تابع <code>draw</code>، قبل از <span dir="ltr"><code>ctx.beginPath();</code></span>، به <code>strokeStyle</code> مقدار جدید <code>`hsl(${hue}, 100%, 50%)`</code> را بدهید.</li>
<li>در آخر تابع <code>draw</code>، مقدار <code>hue</code> را یکی افزایش دهید تا تغییر رنگ انجام شود.</li>
<li>با آن که وقتی مقدار <code>hue</code> از 360 بیشتر شود مشکلی به وجود نمی‌آید، می‌توانید با یک عبارت شرطی وقتی مقدار آن به 360 رسید، مقدار را دوباره 0 کنید.</li>
</ul>

۱۰. برای تغییر کلفتی خطوط هنگام رسم آن‌ها:
<ul>
<li>بعد از متغیرهای مرحله ۴، یک متغیر <code>direction</code> با مقدار اولیه <code>true</code> تعریف کنید.</li>
<li>در آخر تابع <code>draw</code>، اگر مقدار <code>lineWidth</code> از 100 بیشتر و یا از 1 کمتر شد، مقدار متغیر <code>direction</code> را عوض کنید</li>
<li>بعد از عبارت شرطی بالا، اگر <code>direction</code> مقدار <code>true</code> داشت، مقدار <code>lineWidth</code> را یکی افزایش دهید و در غیر این صورت، مقدار <code>lineWidth</code> را یکی کاهش دهید.</li>
</ul>

۱۱. می‌توانید از Blend Modes داخل `context` و برای خطوط استفاده کنید. برای این کار، بعد از متغیرهای مرحله ۳، بنویسید <span dir="ltr">`ctx.globalCompositeOperation`</span> و آن را برابر هر Blend Mode دلخواه قرار دهید. می‌توانید لیستی از مقادیر ممکن برای globalCompositeOperation را [اینجا](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation) ببینید.

---

✅ یه تمرین طولانی تموم شد! 🎉
</div>