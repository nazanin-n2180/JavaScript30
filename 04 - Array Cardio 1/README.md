<div dir="rtl">

# تمرین ۴: کار با آرایه‌ها

در این تمرین، با متدهای پیش‌فرض `array`ها و نحوه استفاده از آن‌ها آشنا می‌شویم. در فایل اولیه، نتیجه موردنظر و نحوه بدست آوردن آن گفته شده است.


## ۱. متد <span dir="ltr">Array.prototype.filter()</span>
متد <span dir="ltr">`Array.prototype.filter()`</span> برای ساختن یک آرایه جدید استفاده می‌شود که شامل تمام عناصری از آرایه اصلی است که تابع شرطی ارائه‌شده برای آن‌ها مقدار صحیح (truthy) برگردانده است. هدف این متد، امکان استخراج زیرمجموعه‌ای از عناصر آرایه بر اساس معیارهای خاص است، بدون اینکه آرایه اصلی تغییر کند.

سینتکس این متد به صورت `arr.filter(callbackFn[, thisArg])` است که در آن `callbackFn` تابعی است که با سه آرگومان `(currentValue, currentIndex, array)` فراخوانی می‌شود. آرگومان اختیاری `thisArg` برای تعیین مقدار `this` در داخل تابع callback هنگام اجرا استفاده می‌شود. همچنین اگر تابع callback از آرگومان‌های `currentIndex` و `array` استفاده نکند، می‌توان از آن‌ها صرف نظر کرد.

زمانی که این متد اجرا می‌شود، ابتدا طول آرایه (`length`) تعیین می‌شود و سپس اندیس‌ها از `0` تا `length - 1` پیمایش می‌شوند. برای هر اندیسی که مقدار دارد (یعنی جایی که عنصر موجود است)، تابع callback فراخوانی می‌شود. اگر مقدار برگشتی callback برای آن عنصر مقدار صحیح باشد، آن عنصر به آرایه نتیجه اضافه می‌شود که به ترتیب و بدون شکاف از اندیس `0` شروع به رشد می‌کند. آرایه‌های پراکنده (sparse) به گونه‌ای مدیریت می‌شوند که خانه‌های خالی (اندیس‌های ناموجود) نادیده گرفته شده و این خانه‌ها در آرایه خروجی که همواره متراکم است، ظاهر نمی‌شوند. هر تغییری که روی عناصر قبل از رسیدن به نوبت آن‌ها در حلقه داده شود، روی مقدار ارسالی به callback تاثیر می‌گذارد اما عناصر اضافه شده پس از طول اولیه‌ی تعیین شده کاملاً نادیده گرفته می‌شوند.

مقدار بازگشتی <span dir="ltr">`filter()`</span> یک آرایه جدید و متراکم است که فقط شامل عناصری است که از آزمون تابع شرط عبور کرده‌اند و ترتیب اصلی آن‌ها در آرایه مبدأ حفظ شده است. این متد به طور ذاتی آرایه اصلی را تغییر نمی‌دهد، مگر اینکه خود تابع callback این کار را انجام دهد.

اگر `callbackFn` قابل فراخوانی نباشد، این متد خطای `TypeError` برمی‌گرداند. پیچیدگی زمانی آن به صورت خطی نسبت به تعداد اندیس‌های پردازش شده است (O(n)). این متد به خصوص برای استخراج زیرمجموعه‌های داده بدون نیاز به حفظ اندیس‌های اصلی بسیار موثر است و تضمین می‌کند که آرایه خروجی بدون خانه‌های خالی و همواره متراکم باشد.


## ۲. متد <span dir="ltr">Array.prototype.map()</span>
از این متد برای ساخت یک آرایه جدید استفاده می‌شود. آرایه ساخته شده شامل مقادیری است که از اجرای یک تابع مشخص روی هر عنصر موجود در آرایه منبع به‌دست می‌آید. این متد آرایه اصلی را تغییر نمی‌دهد، مگر اینکه این چنین تغییراتی مستقیماً در داخل تابع callback اعمال شده باشند و ساختار آرایه ورودی — حتی شامل فضاهای خالی در آرایه‌های پراکنده — را حفظ می‌کند.

ساختار این متد به صورت `arr.map(callbackFn[, thisArg])` است. تابع `callbackFn` با سه آرگومان فراخوانی می‌شود: `(currentValue, currentIndex, array)`. آرگومان اختیاری `thisArg` نیز می‌تواند برای تعیین مقدار `this` در داخل تابع `callbackFn` ارائه شود. همچنین اگر تابع callback فقط از آرگومان `currentValue` استفاده کند، می‌توان از آرگومان‌های `currentIndex` و `array` صرف نظر کرد.

در زمان اجرا، ابتدا <span dir="ltr">`map()`</span> مقدار `this` را به یک شئ تبدیل کرده و طول آن را با استفاده از `ToLength(Get(O, "length"))` به‌دست می‌آورد. این مقدار طول برای کل عملیات ثابت می‌ماند. سپس متد، ایندکس‌ها را از `0` تا `length - 1` به ترتیب صعودی پیمایش می‌کند. برای هر ایندکس، وجود آن ویژگی با استفاده از `HasProperty` بررسی می‌شود. تابع بازخوان تنها برای ویژگی‌های موجود اجرا می‌شود. فضاهای خالی (holes) در آرایه‌های پراکنده کاملاً نادیده گرفته شده و تابع برای آن‌ها فراخوانی نمی‌شود.

اگر تابع بازخوان برای یک ایندکس مشخص اجرا شود، مقدار بازگشتی آن در همان ایندکس از آرایه نتیجه ذخیره می‌شود. اگر ایندکس متناظر در آرایه منبع یک فضای خالی باشد، همان ایندکس در نتیجه نیز خالی می‌ماند، بنابراین پراکندگی آرایه حفظ می‌شود. هر تغییری که قبل از بازدید یک ایندکس روی آرایه اعمال شود، روی مقداری که به تابع ارسال می‌شود اثر می‌گذارد. با این حال، عناصری که در ایندکس‌های بزرگ‌تر یا مساوی طول اولیه افزوده شوند نادیده گرفته می‌شوند، زیرا دامنه پیمایش از ابتدا مشخص شده است.

مقدار بازگشتی همیشه یک آرایه جدید با همان طول آرایه اصلی است. ایندکس‌های موجود شامل نتایج تابع بازخوان خواهند بود، و ایندکس‌های خالی همچنان خالی باقی می‌مانند. از آنجا که متد یک آرایه جدید برمی‌گرداند، آرایه اصلی تغییر نمی‌کند مگر اینکه تابع بازخوان آن را مستقیماً تغییر دهد.

اگر `callbackFn` یک تابع قابل فراخوانی نباشد، یک خطای `TypeError` ایجاد می‌شود. از نظر عملکرد، این متد در زمان خطی نسبت به تعداد ایندکس‌های بررسی‌شده اجرا می‌شود (O(n) که در آن `n` برابر طول آرایه است).

در نهایت، `map()` به‌صورت عمومی روی اشیاء شبه‌آرایه (دارای ویژگی `length` و کلیدهای عددی) کار می‌کند، به‌خصوص زمانی که با `call` یا `apply` استفاده شود.


## ۳. متد <span dir="ltr">Array.prototype.sort()</span>
متد <span dir="ltr">`Array.prototype.sort()`</span> در جاوااسکریپت متدی است که برای مرتب‌سازی عناصر یک آرایه بر اساس یک تابع مقایسه‌گر طراحی شده و همان آرایه را با عناصر مرتب‌شده بازمی‌گرداند. این عملیات **به‌صورت درجا** انجام می‌شود؛ یعنی آرایه مستقیماً تغییر می‌کند و آرایه جدیدی ساخته نمی‌شود. هدف اصلی این متد، مرتب‌سازی عناصر با استفاده از یک مقایسه‌گر سفارشی یا ترتیب پیش‌فرض (در صورت عدم ارائه مقایسه‌گر) است.

سینتکس این متد به شکل `arr.sort([compareFunction])` است که در آن، پارامتر اختیاری `compareFunction` منطق مرتب‌سازی را تعیین می‌کند. این تابع مقایسه‌گر دو آرگومان `a` و `b` می‌گیرد و باید مقادیر زیر را برگرداند:
<ul>
<li> یک مقدار منفی اگر <code>a</code> باید قبل از <code>b</code> قرار گیرد.</li>
<li> صفر اگر <code>a</code> و <code>b</code> از نظر ترتیب برابر در نظر گرفته شوند.</li>
<li> یک مقدار مثبت اگر <code>a</code> باید بعد از <code>b</code> قرار گیرد.</li>
</ul>

اگر تابع مقایسه‌گر ارائه نشود، `sort` عناصر را به رشته تبدیل کرده و آن‌ها را به‌صورت واژگانی و بر اساس ترتیب واحدهای کد UTF-16 مقایسه می‌کند. این رفتار پیش‌فرض می‌تواند برای داده‌های عددی نتایج غیرمنتظره ایجاد کند، زیرا به دلیل قواعد مقایسه رشته‌ای، `"10"` کوچکتر از `"2"` در نظر گرفته می‌شود.

از نظر **الگوریتمی**، `sort` ابتدا فراخوانی‌کننده را به یک شئ تبدیل می‌کند و از ویژگی `length` آن استفاده می‌کند. این متد تنها ویژگی‌هایی را مرتب می‌کند که مربوط به شاخص‌های معتبر آرایه (از `0` تا `length - 1`) هستند. الگوریتم مرتب‌سازی در استاندارد ECMAScript مشخص نشده و موتورهای مختلف جاوااسکریپت ممکن است الگوریتم‌های متفاوتی پیاده‌سازی کنند. با این حال، نسخه‌های مدرن ECMAScript (از ES2019 به بعد) ملزم هستند که مرتب‌سازی را **پایدار** انجام دهند؛ یعنی عناصری که طبق مقایسه‌گر برابرند، باید ترتیب اولیه خود را حفظ کنند. در نسخه‌های قدیمی‌تر و موتورهای قدیمی، پایداری مرتب‌سازی تضمین نمی‌شد. تابع مقایسه‌گر، در صورت ارائه، ممکن است چندین بار در طول مرتب‌سازی فراخوانی شود و مقادیر بازگشتی آن با عملیات `ToNumber` به اعداد تبدیل می‌شود. اگر مقایسه‌گر ناسازگار باشد—مثل غیرانتقالی بودن—نتیجه نهایی ممکن است غیرقابل پیش‌بینی و وابسته به پیاده‌سازی باشد.

در مواجهه با **آرایه‌های پراکنده** (دارای عناصر مفقود)، نحوه مدیریت خانه‌های خالی و مقادیر `undefined` نیز به پیاده‌سازی وابسته است. به‌طور معمول، تنها عناصر موجود مقایسه می‌شوند و خانه‌های خالی یا مقادیر `undefined` در اکثر موتورهای جاوااسکریپت به انتهای آرایه منتقل می‌شوند اما موقعیت دقیق این خانه‌ها در محیط‌های مختلف یکسان نیست.

**خروجی** متد `sort` همان شئ آرایه است که بر اساس مقایسه‌گر یا رفتار پیش‌فرض بازآرایی شده است. این یعنی متد **آرایه اصلی را تغییر می‌دهد**، بنابراین اگر نیاز به حفظ ترتیب اولیه دارید، باید قبل از مرتب‌سازی یک کپی بگیرید. چون مرتب‌سازی همیشه درجا انجام می‌شود، این متد دارای اثرات جانبی است که می‌تواند سایر بخش‌های کد که به همان آرایه ارجاع می‌دهند را تحت تأثیر قرار دهد.

اگر `compareFunction` ارائه شود اما قابل فراخوانی نباشد، یک خطای `TypeError` ایجاد می‌شود. از نظر کارایی، ECMAScript پیچیدگی زمانی خاصی را الزامی نکرده اما پیاده‌سازی‌های معمول هدف را میانگین زمانی O(n log n) قرار می‌دهند، هرچند عملکرد دقیق به موتور جاوااسکریپت و ویژگی‌های داده ورودی بستگی دارد.

یک **نکته مهم** برای مرتب‌سازی عددی این است که باید یک مقایسه‌گر سفارشی ارائه شود تا ترتیب عددی صحیح تضمین شود. در غیر این صورت، مقایسه رشته‌ای پیش‌فرض باعث ایجاد ترتیب واژگانی می‌شود که معمولاً برای اعداد مطلوب نیست.

متد <span dir="ltr">`Array.prototype.sort()`</span> یک متد قدرتمند اما درجا و گاهی پیچیده است—به‌خصوص اگر مقایسه‌گر حذف شود، ناسازگار باشد یا آرایه شامل مقادیر خاصی مثل `undefined` یا عناصر مفقود باشد.


## ۴. متد <span dir="ltr">Array.prototype.reduce()</span>
متد <span dir="ltr">`Array.prototype.reduce()`</span> یک متد داخلی در جاوااسکریپت است که برای تجمیع مقادیر یک آرایه به یک نتیجه واحد استفاده می‌شود. این کار با اجرای مکرر یک تابع کاهش‌دهنده (reducer) انجام می‌شود که روی یک **تجمع‌کننده (accumulator)** و عنصر فعلی عمل می‌کند. شکل کلی استفاده به صورت `arr.reduce(reducerFn[, initialValue])` است که در آن `reducerFn` تابعی است که روی هر عنصر اعمال می‌شود و `initialValue` یک مقدار اختیاری برای مقدار اولیه‌ی تجمع‌کننده است. تابع کاهش‌دهنده چهار آرگومان دریافت می‌کند: تجمع‌کننده، مقدار فعلی، اندیس فعلی و آرایه اصلی.

در سطح داخلی، این متد ابتدا مقدار `this` را به یک شئ تبدیل کرده و ویژگی `length` آن را در ابتدای اجرا یک‌بار می‌خواند. سپس روی اندیس‌های آرایه از `0` تا `length - 1` پیمایش می‌کند. رفتار متد بسته به این که `initialValue` داده شده باشد یا نه متفاوت است. اگر مقدار اولیه داده شده باشد، تجمع‌کننده با همین مقدار مقداردهی می‌شود و تابع کاهش‌دهنده برای هر عنصر موجود (present) از اندیس `0` به بعد فراخوانی می‌شود، به شرطی که آن اندیس پر باشد. اگر مقدار اولیه داده نشده باشد، متد به دنبال اولین عنصر موجود (غیر‌حفره) می‌گردد تا به عنوان مقدار اولیه تجمع‌کننده استفاده کند. اگر چنین عنصری در اندیس `k` پیدا شود، پیمایش از عنصر موجود بعد از `k` ادامه پیدا می‌کند. اگر هیچ عنصر موجودی نباشد—چه آرایه خالی باشد و چه تمام عناصر آن حفره باشند—یک خطای `TypeError` ایجاد می‌شود.

فقط عناصر موجود بازدید می‌شوند، به این معنی که حفره‌ها در آرایه‌های پراکنده کاملاً نادیده گرفته می‌شوند. اگر عنصری قبل از بازدید تغییر کند، مقدار به‌روزشده آن هنگام رسیدن به اندیس موردنظر استفاده می‌شود. هر عنصری که بعد از تعیین طول اولیه به آرایه اضافه شود، نادیده گرفته می‌شود. پس از پردازش تمام عناصر بازدید شده، متد مقدار نهایی تجمع‌کننده را بازمی‌گرداند.

متد <span dir="ltr">`reduce()`</span> به طور ذاتی آرایه اصلی را تغییر نمی‌دهد اما تابع کاهش‌دهنده می‌تواند باعث تغییر آن یا متغیرهای خارجی شود. از آن‌جا که این متد یک مقدار واحد تولید می‌کند و نه یک آرایه جدید، معمولاً برای کارهای تجمیع، تبدیل یا محاسبات استفاده می‌شود. اگر `reducerFn` ارائه‌شده قابل فراخوانی نباشد یا اگر مقدار اولیه داده نشده باشد و آرایه هیچ عنصر موجودی نداشته باشد، خطا رخ می‌دهد.

پیچیدگی محاسباتی <span dir="ltr">`reduce()`</span> نسبت به تعداد اندیس‌های بررسی‌شده خطی است (O(n)). انعطاف‌پذیری آن باعث می‌شود ابزار قدرتمندی در جاوااسکریپت باشد—به گونه‌ای که می‌تواند رفتار بسیاری از متدهای دیگر آرایه مثل `map`، `filter`، `group` یا `flatten` را شبیه‌سازی کند—اما برای جلوگیری از خطا، باید قوانین مربوط به مقدار اولیه و آرایه‌های پراکنده با دقت رعایت شوند.


---
> برای توضیحات بیشتر درباره این متدها، از داکیومنت‌هایی مثل [Mozilla docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/) می‌تونید استفاده کنید.

✅ و تمام!

</div>