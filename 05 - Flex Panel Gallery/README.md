<div dir="rtl">

# تمرین ۵: گالری تصویر با Flex

در این تمرین یک صفحه وب در اختیار داریم که شامل پنج عنصر `div` با کلاس `panel` است. هر کدام از این پنل‌ها شامل سه عنصر `p` می‌باشند که دارای متن هستند. این پنل‌ها درون یک عنصر `div` با کلاس `panels` قرار گرفته‌اند. در حالت اولیه، این پنل‌ها به‌صورت عمودی روی هم قرار گرفته‌اند و هیچ‌گونه تعاملی ندارند. هدف این است که این پنل‌ها به‌صورت افقی نمایش داده شوند و فقط متن میانی (عنصر `p` دوم) قابل مشاهده باشد. سپس، زمانی که کاربر روی یکی از این پنل‌ها کلیک می‌کند، آن پنل باز شده و دو متن دیگر (ابتدایی و انتهایی) نیز ظاهر شوند. برای این منظور لازم است CSS و JavaScript را تکمیل کنیم تا این تعامل به درستی اجرا شود.

> این تمرین بیشتر روی **flexbox در CSS3** تمرکز دارد. اگر با flexbox آشنایی ندارید، می‌توانید از دوره رایگان [flexbox.io](http://flexbox.io) استفاده کنید.


## خلاصه

در طراحی با Flexbox، یک **flex container** داریم که شامل چند **flex item** است. در این تمرین:

<ul>
<li> کلاس <code>panels</code> نقش flex container را دارد.  </li>
<li> کلاس <code>panel</code> نقش flex item را دارد.  </li>
</ul>

به‌طور پیش‌فرض، flex itemها فقط به اندازه محتوای خودشان فضا می‌گیرند. اما ما می‌خواهیم این پنل‌ها فضای کل container را پر کنند و به‌صورت مساوی توزیع شوند. برای همین لازم است اجازه دهیم پنل‌ها **grow** داشته باشند.

از آنجا که محتوای هر پنل هم باید انعطاف‌پذیر باشد، هر پنل (`panel`) را همزمان به‌عنوان **flex item** و **flex container** در نظر می‌گیریم. به این معنا که پنل‌ها نسبت به container اصلی (`panels`) تنظیم می‌شوند، و محتوای درون هر پنل (سه عنصر `p`) نیز نسبت به همان پنل به‌عنوان container تنظیم می‌شوند.


## مراحل پیاده‌سازی

### قسمت CSS:

۱. کلاس `panels` را به یک flex container تبدیل می‌کنیم.

```css
.panels {
  display: flex;
}
```

۲. به ویژگی‌های کلاس `panel`، `flex: 1;` را اضافه می‌کنیم تا هر کدام از flex itemها به‌طور مساوی فضای container را پر کنند.

```css
.panel {
  flex: 1;
}
```

۳. در CSS، عناصر می‌توانند هم flex container باشند و هم flex item. هر ‍`panel` را به یک flex container تبدیل می‌کنیم. با این کار، به‌طور پیش‌فرض عناصر فرزند `panel` بصورت افقی چیده می‌شوند. برای عمودی شدن چینش عناصر، از `flex-direction: column;` استفاده می‌کنیم.

```css
.panel {
  display: flex;
  flex-direction: column;
}
```

۴. برای عناصر فرزند `panel` (یعنی همان `p`ها) هم `display: flex;` تعریف می‌کنیم. در آخر، صفحه ما شامل چند عنصر flex تودرتو خواهد بود. به‌صورت پیش‌فرض، متن داخل عناصر `p` در بالا و سمت چپ container خود قرار می‌گیرند و آن‌ها را با استفاده از `justify-content: center;` و `align-items: center;` دقیقا در وسط containerشان قرار می‌دهیم.

```css
.panel > * {
  flex: 1 0 auto;
  display: flex;
  justify-content: center;
  align-items: center;
}
```

۵. اولین و آخرین عنصر فرزند را ابتدا به بیرون صفحه منتقل می‌کنیم و وقتی پنل فعال شد، آن‌ها را دوباره برمی‌گردانیم.

```css
.panel > *:first-child {
  transform: translateY(-100%);
}

.panel.open-active > *:first-child {
  transform: translateY(0);
}

.panel > *:last-child {
  transform: translateY(100%);
}

.panel.open-active > *:last-child {
  transform: translateY(0);
}
```

۶. به کلاس `panel open`، `flex: 5;` را اضافه می‌کنیم تا پنل کلیک شده ۵ برابر بزرگ‌‌تر از بقیه پنل‌ها نمایش داده شود.

   ```css
   .panel.open {
     flex: 5;
   }
   ```

### قسمت JavaScript:

۱. یک متغیر تعریف کرده و با استفاده از `document.querySelectorAll('.panel')`، لیست همه پنل‌ها را در آن ذخیره می‌کنیم.

۲. روی همه این عناصر پیمایش کنید و برای رویداد `click` یک **event listener** اضافه کنید که یک تابع event handler را اجرا کند.

**نکته:** هنگام استفاده از `addEventListener` باید نام تابع را **بدون پرانتز** بنویسید.  مثلا `addEventListener('click', toggleOpen)` درست است، اما `addEventListener('click', toggleOpen())` باعث می‌شود تابع در لحظه بارگذاری صفحه اجرا شود.  چیزی که ما می‌خواهیم این است که فقط **آدرس/ارجاع تابع** را بدهیم تا مرورگر بداند وقتی کاربر روی این عنصر کلیک کرد، آن موقع باید این تابع را اجرا کند.

۳. همان کار را برای رویداد `transitionend` انجام دهید و یک تابع دیگر به‌عنوان handler مشخص کنید.

۴. تابع مربوط به مرحله ۲ باید کلاس `open` را روی عنصر کلیک‌شده toggle کند.

۵. تابع مربوط به مرحله ۳ باید کلاس `open-active` را روی عنصری که transition آن تمام شده toggle کند. معمولا در این صورت می‌نویسیم `this.classList.toggle('open-active');` اما در این صفحه ممکن است چند رویداد `transitionend` اتفاق بیوفتند که همه آن‌ها مورد نظر ما نیست. برای اختصاصی کردن اجرای دستورات این تابع، فقط در صورتی که ویژگی event شامل واژه‌ی `'flex'` باشد آن‌ها را اجرا می‌کنیم.

> **اتفاقی که میوفته اینه:** وقتی روی یکی از تصاویر کلیک میشه، به پنل اون تصویر کلاس open اضافه میشه و transition انجام میده. بعدش وقتی اون transition تموم میشه، کلاس open-active به همون پنل اضافه میشه و متن‌های مخفی شده روی صفحه ظاهر میشن. در صورت کلیک دوباره روی یک پنل فعال، همین پروسه برای اون پنل انجام میشه ولی این بار کلاس‌های open و open-active از کلاس‌های اون پنل حذف میشن. اگه بخوایم، می‌تونیم بیشتر از یک پنل فعال روی صفحه داشته باشیم.

---

🎉 تمرین ۵ به پایان رسید!

</div>